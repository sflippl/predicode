{
 "cells": [
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# Explore the Hierarchical class"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "This notebook explores the base functionality of Hierarchical as this base functionality is introduced."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "For now, Hierarchical is indeed instantiated as a subclass of Sequential, but only inherits the methods that specify how the layer architecture works. If more general architectures are added, the actual implementation will be moved up. Currently, this implementation already involves the general Model API in keras."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Methods in Sequential"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 8,
   "metadata": {},
   "outputs": [],
   "source": [
    "import tensorflow.keras as keras\n",
    "seq = keras.Sequential()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 4,
   "metadata": {},
   "outputs": [],
   "source": [
    "seq.add(keras.layers.Dense(10, input_shape=(4, )))"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 5,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Model: \"sequential\"\n",
      "_________________________________________________________________\n",
      "Layer (type)                 Output Shape              Param #   \n",
      "=================================================================\n",
      "dense (Dense)                (None, 10)                50        \n",
      "=================================================================\n",
      "Total params: 50\n",
      "Trainable params: 50\n",
      "Non-trainable params: 0\n",
      "_________________________________________________________________\n"
     ]
    }
   ],
   "source": [
    "seq.summary()"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Essentially, the thing we must add is a possibility to infer arbitrary states; essentially a state layer. Later, this will be ample opportunity to specify different kinds of state layers (think probabilistic, a la Srinivasan, etc.). Later, we may thus have more than two different modes of estimation, but for now, we have state and weight parameter estimation. This means that effectively, we have multiple sequential models -- which also means that we might as well just explicitly have an entirely new class."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "The overall UI should enable state-to-state thinking. Conceptually, there are two levels of a predictive coding model: on one level, there are the state inference layers. On the other hand, each of these inferred states is being used to predict the state blow, the lowest state being actually observed. The supernetworks should be specified in a bottom-up fashion, whereas the subnetworks should be specified in a top-down fashion. When Hierarchical is initialized, it should thus be initialized in a top-down fashion."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "The following syntax thus seems sensible:"
   ]
  },
  {
   "cell_type": "raw",
   "metadata": {},
   "source": [
    "hpc = pc.Hierarchical()\n",
    "hpc.add(\n",
    "    keras.Sequential(\n",
    "        [pc.layers.State(input_shape=(4, )),\n",
    "         keras.layers.Dense(10),\n",
    "         pc.layers.StateEstimation()]\n",
    "    )\n",
    ")\n",
    "print(hpc)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Or, as a more complex example:"
   ]
  },
  {
   "cell_type": "raw",
   "metadata": {},
   "source": [
    "nl_hpc = pc.Hierarchical()\n",
    "nl_hpc.add(pc.layers.State(input_shape=(4, )))\n",
    "nl_hpc.add(\n",
    "    keras.Sequential(\n",
    "         keras.layers.activation('relu', input_shape=(4, )),\n",
    "         keras.layers.Dense(10),\n",
    "         pc.layers.StateEstimation()]\n",
    "    )\n",
    ")\n",
    "nl_hpc.add(pc.layers.StateEstimation())\n",
    "# Current state estimation loop closed. Moving up one tier.\n",
    "nl_hpc.add(pc.layers.State(input_shape=(4, )))\n",
    "\n",
    "nl_hpc.add(\n",
    "    keras.Sequential(\n",
    "         keras.layers.Dense(10),\n",
    "         keras.layers.activation('relu'),\n",
    "         keras.layers.Dense(4)]\n",
    "    )\n",
    ")\n",
    "print(nl_hpc)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Pro: Hierarchical models can be built in a bottom up fashion.\n",
    "Con: There's a somewhat unnecessary doubling of state estimation and state -- or at least the input shape there.\n",
    "However, I can see certain advantages with that kind of verbosity, as well."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "As a first step, I will implement the pure interface plus printing.\n"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Revamp: There are essentially three different modi: adding the state tiers, adding the tier models, and adding the connections between the tiers."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 6,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Model: \"sequential_1\"\n",
      "_________________________________________________________________\n",
      "Layer (type)                 Output Shape              Param #   \n",
      "=================================================================\n",
      "dense_1 (Dense)              (None, 10)                50        \n",
      "_________________________________________________________________\n",
      "activation (Activation)      (None, 10)                0         \n",
      "_________________________________________________________________\n",
      "dense_2 (Dense)              (None, 4)                 44        \n",
      "=================================================================\n",
      "Total params: 94\n",
      "Trainable params: 94\n",
      "Non-trainable params: 0\n",
      "_________________________________________________________________\n"
     ]
    }
   ],
   "source": [
    "seq = keras.Sequential()\n",
    "seq.add(keras.layers.Dense(10, input_shape=(4, )))\n",
    "seq.add(keras.layers.Activation('relu'))\n",
    "seq.add(keras.layers.Dense(4))\n",
    "seq.summary()"
   ]
  },
  {
   "cell_type": "raw",
   "metadata": {},
   "source": [
    "nl_hpc = pc.Hierarchical()\n",
    "nl_hpc.add_tier(shape=(10, ))\n",
    "# Adding 'Tier 0'.\n",
    "nl_hpc.add_tier(shape=(4, ))\n",
    "# Adding 'Tier 1'.\n",
    "nl_hpc.add_tier(shape=(2, ), name='Final Tier')\n",
    "# Adding 'Final Tier' (Tier 2).\n",
    "nl_hpc.summary()\n",
    "# -------------------------------------------------------------------\n",
    "# Layer (type)               Output Shape               Param #\n",
    "# ===================================================================\n",
    "# TIER_2\n",
    "# -------------------------------------------------------------------\n",
    "# (Missing Model.)\n",
    "# -------------------------------------------------------------------\n",
    "# (Missing State Prediction.)\n",
    "# -------------------------------------------------------------------\n",
    "# TIER_1\n",
    "# -------------------------------------------------------------------\n",
    "# (Missing Model.)\n",
    "# -------------------------------------------------------------------\n",
    "# (Missing State Prediction.)\n",
    "# -------------------------------------------------------------------\n",
    "# TIER_0\n",
    "# ==================================================================="
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Importantly, we separate the user interface from the implementation via the appropriate class methods. Though I have not looked at that yet, this should make an alternative backend to Tensorflow easier."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "This kind of interface has now been achieved:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 9,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "# Tier 1: tier_1\n",
      "## Connecting Predictor\n",
      "Model: \"sequential_3\"\n",
      "_________________________________________________________________\n",
      "Layer (type)                 Output Shape              Param #   \n",
      "=================================================================\n",
      "dense_3 (Dense)              (None, 4)                 44        \n",
      "=================================================================\n",
      "Total params: 44\n",
      "Trainable params: 44\n",
      "Non-trainable params: 0\n",
      "_________________________________________________________________\n",
      "## Connection State Prediction\n",
      "(No state prediction defined.)\n",
      "# Tier 0: tier_0\n"
     ]
    }
   ],
   "source": [
    "import predicode as pc\n",
    "hpc = pc.Hierarchical()\n",
    "hpc.add_tier(shape=(10, ))\n",
    "hpc.add_tier(shape=(4, ))\n",
    "hpc.predictor = keras.Sequential()\n",
    "hpc.predictor.add(keras.layers.Dense(4, input_shape=(10, )))\n",
    "hpc.summary()"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Now, we tackle the real meat of Hierarchical: the estimation."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Example estimation"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Our estimation consists of an interplay between state variables and their corresponding minimizers, and models and their corresponding minimizers."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Example data"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 187,
   "metadata": {},
   "outputs": [],
   "source": [
    "art = pc.decaying_multi_normal(dimensions=10, size=100)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 188,
   "metadata": {},
   "outputs": [],
   "source": [
    "import tensorflow as tf"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### State variables"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 189,
   "metadata": {},
   "outputs": [],
   "source": [
    "tier_0 = tf.constant(art, name = 'tier_0', dtype=tf.float32)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 190,
   "metadata": {},
   "outputs": [],
   "source": [
    "tier_1_initial = pc.init('random', columns=4, rows=100)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 191,
   "metadata": {},
   "outputs": [],
   "source": [
    "tier_1 = tf.Variable(tier_1_initial, name = 'hierarchical_1_tier_1', shape = (None, 4), dtype=tf.float32)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Predictors"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 192,
   "metadata": {},
   "outputs": [],
   "source": [
    "predictor_1 = keras.Sequential([keras.layers.Dense(10, input_shape=(4, ), use_bias=False)])"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 193,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "<tensorflow.python.keras.engine.sequential.Sequential at 0x7fa44c3517d0>"
      ]
     },
     "execution_count": 193,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "predictor_1"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### State prediction"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 194,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "tf.Tensor([ 0.06916584  0.10295527 -0.01925885  0.01391548], shape=(4,), dtype=float32)\n"
     ]
    }
   ],
   "source": [
    "with tf.GradientTape() as tape:\n",
    "    predicted_1 = predictor_1(tier_1)\n",
    "    loss = keras.losses.mean_squared_error(tier_0, predicted_1)\n",
    "grad = tape.gradient(loss, (tier_1))\n",
    "print(grad[0])"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 195,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "<tf.Tensor: id=2543, shape=(10,), dtype=float32, numpy=\n",
       "array([-0.01579765, -0.15295589,  0.03884996, -0.09921838, -0.09088165,\n",
       "        0.02863319,  0.10915829, -0.07180928, -0.07390705,  0.03274121],\n",
       "      dtype=float32)>"
      ]
     },
     "execution_count": 195,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "predicted_1[0]"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 196,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "<tf.Tensor: id=2548, shape=(4,), dtype=float32, numpy=array([ 0.02607813,  0.06078077,  0.23898624, -0.023039  ], dtype=float32)>"
      ]
     },
     "execution_count": 196,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "tier_1[0]"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### State estimation"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 197,
   "metadata": {},
   "outputs": [],
   "source": [
    "state_optimizer = keras.optimizers.SGD(learning_rate=1)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 198,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "(<tf.Tensor: id=2552, shape=(), dtype=float32, numpy=0.22856279>,)"
      ]
     },
     "execution_count": 198,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "next(zip(loss))"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 199,
   "metadata": {},
   "outputs": [],
   "source": [
    "state_step = state_optimizer.apply_gradients(zip([grad], [tier_1]))"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 200,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "<tf.Variable 'SGD/iter:0' shape=() dtype=int64, numpy=1>"
      ]
     },
     "execution_count": 200,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "state_optimizer.iterations"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 201,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "<tf.Tensor: id=2590, shape=(4,), dtype=float32, numpy=array([-0.04308771, -0.0421745 ,  0.25824508, -0.03695448], dtype=float32)>"
      ]
     },
     "execution_count": 201,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "tier_1[0]"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Predictor estimation"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 202,
   "metadata": {},
   "outputs": [],
   "source": [
    "predictor_optimizer = keras.optimizers.SGD(learning_rate=1)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 205,
   "metadata": {},
   "outputs": [],
   "source": [
    "old_predictor = predictor_1.trainable_variables[0].numpy()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 206,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "array([[ 0.44276857, -0.43209442,  0.17139822, -0.51473606, -0.56620896,\n",
       "        -0.65066326, -0.30062282, -0.6243234 , -0.43783697,  0.1630798 ],\n",
       "       [ 0.4224726 , -0.607174  , -0.4189397 ,  0.5001584 , -0.6204565 ,\n",
       "        -0.60774255, -0.25291806,  0.33532977,  0.299918  ,  0.19814217],\n",
       "       [-0.25638744, -0.49725708,  0.19702882, -0.44613242, -0.17868066,\n",
       "         0.37250507,  0.59341705, -0.321252  , -0.2927201 ,  0.01704144],\n",
       "       [-0.35811612, -0.61002773, -0.55369246,  0.41562295, -0.18655622,\n",
       "         0.28140354,  0.4100864 , -0.0375495 ,  0.46713197, -0.5370237 ]],\n",
       "      dtype=float32)"
      ]
     },
     "execution_count": 206,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "old_predictor"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 207,
   "metadata": {},
   "outputs": [],
   "source": [
    "with tf.GradientTape() as tape:\n",
    "    predicted_1 = predictor_1(tier_1)\n",
    "    loss = keras.losses.mean_squared_error(tier_0, predicted_1)\n",
    "grad = tape.gradient(loss, predictor_1.trainable_variables)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 208,
   "metadata": {},
   "outputs": [],
   "source": [
    "weight_step = predictor_optimizer.apply_gradients(zip(grad, predictor_1.trainable_variables))"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 209,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "[<tf.Variable 'dense_10/kernel:0' shape=(4, 10) dtype=float32, numpy=\n",
       " array([[ 0.4696756 , -0.4434791 ,  0.2639745 , -0.4105692 , -0.47405636,\n",
       "         -0.6944158 , -0.2844717 , -0.57967776, -0.4255136 ,  0.23772639],\n",
       "        [ 0.82107085, -0.94557595, -0.09670267,  1.123899  , -0.13716647,\n",
       "         -0.5480783 , -0.43161672,  0.03455314,  0.16572572,  0.20997912],\n",
       "        [-0.49135643, -0.21195328, -0.04334433, -0.8381622 , -0.43875095,\n",
       "          0.32675242,  0.65597695, -0.13594578, -0.210888  , -0.06418005],\n",
       "        [-0.06650856, -0.83621234, -0.54794526,  0.84050214,  0.0666967 ,\n",
       "          0.56812316,  0.22651352, -0.3102327 ,  0.28204638, -0.67964333]],\n",
       "       dtype=float32)>]"
      ]
     },
     "execution_count": 209,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "predictor_1.trainable_variables"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 210,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "array([[ 0.44276857, -0.43209442,  0.17139822, -0.51473606, -0.56620896,\n",
       "        -0.65066326, -0.30062282, -0.6243234 , -0.43783697,  0.1630798 ],\n",
       "       [ 0.4224726 , -0.607174  , -0.4189397 ,  0.5001584 , -0.6204565 ,\n",
       "        -0.60774255, -0.25291806,  0.33532977,  0.299918  ,  0.19814217],\n",
       "       [-0.25638744, -0.49725708,  0.19702882, -0.44613242, -0.17868066,\n",
       "         0.37250507,  0.59341705, -0.321252  , -0.2927201 ,  0.01704144],\n",
       "       [-0.35811612, -0.61002773, -0.55369246,  0.41562295, -0.18655622,\n",
       "         0.28140354,  0.4100864 , -0.0375495 ,  0.46713197, -0.5370237 ]],\n",
       "      dtype=float32)"
      ]
     },
     "execution_count": 210,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "old_predictor"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 186,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "<tf.Tensor: id=2483, shape=(), dtype=bool, numpy=False>"
      ]
     },
     "execution_count": 186,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "eps_pred = tf.math.reduce_mean(tf.losses.mean_squared_error(predictor_1.trainable_variables, old_predictor))\n",
    "eps_pred < 1e-5"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "This ought to have given us some intuition for how this process should work, so we will now single out the different steps. Clearly, the tiers should simply be Tensorflow variables."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": []
  },
  {
   "cell_type": "code",
   "execution_count": 478,
   "metadata": {},
   "outputs": [],
   "source": [
    "import sklearn.decomposition as decomp"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 493,
   "metadata": {},
   "outputs": [],
   "source": [
    "pca = decomp.PCA(10).fit(art)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 495,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "array([1.21951185e+00, 1.47887111e-01, 1.78051538e-02, 2.19805505e-03,\n",
       "       2.92805709e-04, 4.94937281e-05, 6.15893716e-06, 6.60351392e-07,\n",
       "       1.10990880e-07, 1.06866469e-08])"
      ]
     },
     "execution_count": 495,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "pca_weights = pca.components_[:4]\n",
    "pca.explained_variance_"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 496,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "(4, 10)"
      ]
     },
     "execution_count": 496,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "final_weights[0].shape"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 497,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "array([5.24617272e-03, 1.50873588e-05, 1.14442212e-06, 2.81435079e-07])"
      ]
     },
     "execution_count": 497,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "import scipy\n",
    "angles = scipy.linalg.subspace_angles(final_weights[0].T, pca_weights.T)\n",
    "angles"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 498,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "array([3.00583555e-01, 8.64441984e-04, 6.55705576e-05, 1.61250422e-05])"
      ]
     },
     "execution_count": 498,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "import numpy as np\n",
    "np.rad2deg(angles)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "The algorithm indeed seems to find the PCA subspace. I am not sure why the accuracy is so low, though. (I had increased the iterations and nothing changed.)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 507,
   "metadata": {},
   "outputs": [],
   "source": [
    "normalized_weights = final_weights[0] / np.linalg.norm(final_weights[0], 2, axis=1, keepdims=True)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 512,
   "metadata": {},
   "outputs": [],
   "source": [
    "contribs = np.matmul(np.linalg.inv(pca.components_).T, normalized_weights.T)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 514,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "image/png": "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\n",
      "text/plain": [
       "<Figure size 640x480 with 1 Axes>"
      ]
     },
     "metadata": {
      "needs_background": "light"
     },
     "output_type": "display_data"
    },
    {
     "data": {
      "text/plain": [
       "<ggplot: (8734010135609)>"
      ]
     },
     "execution_count": 514,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "import lazytools_sflippl as lazytools\n",
    "lazytools.matrix_heatmap(contribs, pole=0)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "This speaks a pretty clear language though."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 516,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "array([1.07781646e+00, 1.08374561e+00, 9.05683455e-01, 9.18434088e-01,\n",
       "       4.56237665e-03, 1.25316886e-04, 1.45934388e-03, 3.39127943e-04,\n",
       "       2.85356887e-05, 3.78326325e-04])"
      ]
     },
     "execution_count": 516,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "np.linalg.norm(contribs, 2, axis=1)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Same precision, however. This implies reasonable confidence that all errors are numerical, and we can look at an optimization of that after the first implementation."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### First implementation"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "We first set up this small model:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 2,
   "metadata": {},
   "outputs": [
    {
     "name": "stderr",
     "output_type": "stream",
     "text": [
      "/home/sflippl/.local/lib/python3.7/site-packages/tensorboard/compat/tensorflow_stub/dtypes.py:541: FutureWarning: Passing (type, 1) or '1type' as a synonym of type is deprecated; in a future version of numpy, it will be understood as (type, (1,)) / '(1,)type'.\n",
      "  _np_qint8 = np.dtype([(\"qint8\", np.int8, 1)])\n",
      "/home/sflippl/.local/lib/python3.7/site-packages/tensorboard/compat/tensorflow_stub/dtypes.py:542: FutureWarning: Passing (type, 1) or '1type' as a synonym of type is deprecated; in a future version of numpy, it will be understood as (type, (1,)) / '(1,)type'.\n",
      "  _np_quint8 = np.dtype([(\"quint8\", np.uint8, 1)])\n",
      "/home/sflippl/.local/lib/python3.7/site-packages/tensorboard/compat/tensorflow_stub/dtypes.py:543: FutureWarning: Passing (type, 1) or '1type' as a synonym of type is deprecated; in a future version of numpy, it will be understood as (type, (1,)) / '(1,)type'.\n",
      "  _np_qint16 = np.dtype([(\"qint16\", np.int16, 1)])\n",
      "/home/sflippl/.local/lib/python3.7/site-packages/tensorboard/compat/tensorflow_stub/dtypes.py:544: FutureWarning: Passing (type, 1) or '1type' as a synonym of type is deprecated; in a future version of numpy, it will be understood as (type, (1,)) / '(1,)type'.\n",
      "  _np_quint16 = np.dtype([(\"quint16\", np.uint16, 1)])\n",
      "/home/sflippl/.local/lib/python3.7/site-packages/tensorboard/compat/tensorflow_stub/dtypes.py:545: FutureWarning: Passing (type, 1) or '1type' as a synonym of type is deprecated; in a future version of numpy, it will be understood as (type, (1,)) / '(1,)type'.\n",
      "  _np_qint32 = np.dtype([(\"qint32\", np.int32, 1)])\n",
      "/home/sflippl/.local/lib/python3.7/site-packages/tensorboard/compat/tensorflow_stub/dtypes.py:550: FutureWarning: Passing (type, 1) or '1type' as a synonym of type is deprecated; in a future version of numpy, it will be understood as (type, (1,)) / '(1,)type'.\n",
      "  np_resource = np.dtype([(\"resource\", np.ubyte, 1)])\n"
     ]
    },
    {
     "data": {
      "text/plain": [
       "<predicode.hierarchical.hierarchical.Hierarchical at 0x7fa946d86ed0>"
      ]
     },
     "execution_count": 2,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "import predicode as pc\n",
    "import tensorflow as tf\n",
    "import tensorflow.keras as keras\n",
    "hpc = pc.Hierarchical()\n",
    "hpc.add_tier(shape=(10, ))\n",
    "hpc.add_tier(shape=(4, ),\n",
    "             name='latent_layer')"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 2,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "# Tier 1: latent_layer\n",
      "## Connecting Predictor\n",
      "(No predictor defined.)\n",
      "## Connecting State Prediction\n",
      "(No state prediction defined.)\n",
      "# Tier 0: tier_0\n"
     ]
    }
   ],
   "source": [
    "hpc.summary()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 3,
   "metadata": {},
   "outputs": [],
   "source": [
    "hpc.predictor = keras.Sequential()\n",
    "hpc.predictor.add(\n",
    "    keras.layers.Dense(10, input_shape=(4, ), use_bias=False, dtype=tf.float32)\n",
    ")\n",
    "hpc.state_prediction = pc.StatePrediction()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 4,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "# Tier 1: latent_layer\n",
      "## Connecting Predictor\n",
      "Model: \"sequential\"\n",
      "_________________________________________________________________\n",
      "Layer (type)                 Output Shape              Param #   \n",
      "=================================================================\n",
      "dense (Dense)                (None, 10)                40        \n",
      "=================================================================\n",
      "Total params: 40\n",
      "Trainable params: 40\n",
      "Non-trainable params: 0\n",
      "_________________________________________________________________\n",
      "## Connecting State Prediction\n",
      "Loss-driven state prediction.\n",
      "Loss function: <function mean_squared_error at 0x7fa7d389aa70>\n",
      "# Tier 0: tier_0\n"
     ]
    }
   ],
   "source": [
    "hpc.summary()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 5,
   "metadata": {},
   "outputs": [],
   "source": [
    "hpc._is_ready()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 10,
   "metadata": {},
   "outputs": [],
   "source": [
    "dataset = pc.decaying_multi_normal(dimensions = 10, size = 100).astype('float32')"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 7,
   "metadata": {},
   "outputs": [],
   "source": [
    "state_regimen = pc.SimpleOptimizerRegimen(keras.optimizers.SGD())\n",
    "predictor_regimen = pc.SimpleOptimizerRegimen(keras.optimizers.SGD(), eps=1e-7)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 8,
   "metadata": {},
   "outputs": [],
   "source": [
    "regimen = pc.ExpectationMaximizationRegimen(\n",
    "    state_regimen=state_regimen,\n",
    "    predictor_regimen=predictor_regimen\n",
    ")"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 9,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "<predicode.hierarchical.hierarchical.Hierarchical at 0x7fa7c9ed0850>"
      ]
     },
     "execution_count": 9,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "hpc.train(dataset, regimen, batch_size=50)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 10,
   "metadata": {},
   "outputs": [],
   "source": [
    "import sklearn.decomposition as decomp\n",
    "pca = decomp.PCA(10).fit(dataset)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 11,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "array([1.4611298e-01, 9.7820815e-03, 2.4466366e-03, 4.0570652e-05],\n",
       "      dtype=float32)"
      ]
     },
     "execution_count": 11,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "import scipy\n",
    "angles = scipy.linalg.subspace_angles(hpc.predictor.get_weights()[0].T, pca.components_[:4].T)\n",
    "angles"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 12,
   "metadata": {},
   "outputs": [],
   "source": [
    "import numpy as np\n",
    "normalized_weights = hpc.predictor.get_weights()[0] / np.linalg.norm(hpc.predictor.get_weights()[0], 2, axis=1, keepdims=True)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 13,
   "metadata": {},
   "outputs": [],
   "source": [
    "contribs = np.matmul(np.linalg.inv(pca.components_).T, normalized_weights.T)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 14,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "image/png": "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\n",
      "text/plain": [
       "<Figure size 640x480 with 1 Axes>"
      ]
     },
     "metadata": {
      "needs_background": "light"
     },
     "output_type": "display_data"
    },
    {
     "data": {
      "text/plain": [
       "<ggplot: (8772232143045)>"
      ]
     },
     "execution_count": 14,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "import lazytools_sflippl as lazytools\n",
    "lazytools.matrix_heatmap(contribs, pole=0)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 15,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "TensorShape([50, 4])"
      ]
     },
     "execution_count": 15,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "hpc.tier(1).shape"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 16,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "image/png": "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\n",
      "text/plain": [
       "<Figure size 640x480 with 1 Axes>"
      ]
     },
     "metadata": {
      "needs_background": "light"
     },
     "output_type": "display_data"
    },
    {
     "data": {
      "text/plain": [
       "<ggplot: (8772219091925)>"
      ]
     },
     "execution_count": 16,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "lazytools.matrix_heatmap(hpc.tier(1).numpy(), pole=0)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "(With a full batch, it works even better, but this demonstrates that even distributed estimations are fairly close to the optimal estimation.)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Better optimization algorithm"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 17,
   "metadata": {},
   "outputs": [],
   "source": [
    "hpc = pc.Hierarchical()\n",
    "hpc.add_tier(shape=(10, ))\n",
    "hpc.add_tier(shape=(4, ),\n",
    "             name='latent_layer')\n",
    "hpc.predictor = keras.Sequential()\n",
    "hpc.predictor.add(\n",
    "    keras.layers.Dense(10, input_shape=(4, ), use_bias=False, dtype=tf.float32)\n",
    ")\n",
    "hpc.state_prediction = pc.StatePrediction()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 18,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "# Tier 1: latent_layer\n",
      "## Connecting Predictor\n",
      "Model: \"sequential_1\"\n",
      "_________________________________________________________________\n",
      "Layer (type)                 Output Shape              Param #   \n",
      "=================================================================\n",
      "dense_1 (Dense)              (None, 10)                40        \n",
      "=================================================================\n",
      "Total params: 40\n",
      "Trainable params: 40\n",
      "Non-trainable params: 0\n",
      "_________________________________________________________________\n",
      "## Connecting State Prediction\n",
      "Loss-driven state prediction.\n",
      "Loss function: <function mean_squared_error at 0x7fa7d389aa70>\n",
      "# Tier 0: tier_0\n"
     ]
    }
   ],
   "source": [
    "hpc.summary()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 19,
   "metadata": {},
   "outputs": [],
   "source": [
    "state_regimen = pc.SimpleOptimizerRegimen(keras.optimizers.Adam())\n",
    "predictor_regimen = pc.SimpleOptimizerRegimen(keras.optimizers.Adam(), eps=1e-7)\n",
    "regimen = pc.ExpectationMaximizationRegimen(\n",
    "    state_regimen=state_regimen,\n",
    "    predictor_regimen=predictor_regimen\n",
    ")"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 20,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "<predicode.hierarchical.hierarchical.Hierarchical at 0x7fa71009c190>"
      ]
     },
     "execution_count": 20,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "hpc.train(dataset, regimen)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 21,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "array([1.5056899e-02, 7.4808294e-04, 1.6564263e-05, 3.4811683e-06],\n",
       "      dtype=float32)"
      ]
     },
     "execution_count": 21,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "import scipy\n",
    "angles = scipy.linalg.subspace_angles(hpc.predictor.get_weights()[0].T, pca.components_[:4].T)\n",
    "angles"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 22,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "image/png": "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\n",
      "text/plain": [
       "<Figure size 640x480 with 1 Axes>"
      ]
     },
     "metadata": {
      "needs_background": "light"
     },
     "output_type": "display_data"
    },
    {
     "data": {
      "text/plain": [
       "<ggplot: (8772391293029)>"
      ]
     },
     "execution_count": 22,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "normalized_weights = hpc.predictor.get_weights()[0] / np.linalg.norm(hpc.predictor.get_weights()[0], 2, axis=1, keepdims=True)\n",
    "contribs = np.matmul(np.linalg.inv(pca.components_).T, normalized_weights.T)\n",
    "lazytools.matrix_heatmap(contribs, pole=0)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Nonlinear model"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 23,
   "metadata": {},
   "outputs": [],
   "source": [
    "nl_hpc = pc.Hierarchical()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 47,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "<predicode.hierarchical.hierarchical.Hierarchical at 0x7fcec584bc50>"
      ]
     },
     "execution_count": 47,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "nl_hpc.add_tier(shape=(10, ))\n",
    "nl_hpc.add_tier(shape=(4, ),\n",
    "                name='latent_layer')"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 48,
   "metadata": {},
   "outputs": [],
   "source": [
    "nl_hpc.predictor = keras.Sequential([\n",
    "    keras.layers.Dense(10, input_shape=(4, )),\n",
    "    keras.layers.Activation('relu'),\n",
    "    keras.layers.Dense(10)\n",
    "])"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 49,
   "metadata": {},
   "outputs": [],
   "source": [
    "nl_hpc.state_prediction = pc.StatePrediction()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 50,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "# Tier 1: latent_layer\n",
      "## Connecting Predictor\n",
      "Model: \"sequential_4\"\n",
      "_________________________________________________________________\n",
      "Layer (type)                 Output Shape              Param #   \n",
      "=================================================================\n",
      "dense_6 (Dense)              (None, 10)                50        \n",
      "_________________________________________________________________\n",
      "activation_1 (Activation)    (None, 10)                0         \n",
      "_________________________________________________________________\n",
      "dense_7 (Dense)              (None, 10)                110       \n",
      "=================================================================\n",
      "Total params: 160\n",
      "Trainable params: 160\n",
      "Non-trainable params: 0\n",
      "_________________________________________________________________\n",
      "## Connecting State Prediction\n",
      "Loss-driven state prediction.\n",
      "Loss function: <function mean_squared_error at 0x7fcf79f729e0>\n",
      "# Tier 0: tier_0\n"
     ]
    }
   ],
   "source": [
    "nl_hpc.summary()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 55,
   "metadata": {},
   "outputs": [],
   "source": [
    "state_regimen = pc.SimpleOptimizerRegimen(keras.optimizers.Adam())\n",
    "predictor_regimen = pc.SimpleOptimizerRegimen(keras.optimizers.Adam(), eps=1e-3)\n",
    "regimen = pc.ExpectationMaximizationRegimen(\n",
    "    state_regimen=state_regimen,\n",
    "    predictor_regimen=predictor_regimen\n",
    ")"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 56,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "<predicode.hierarchical.hierarchical.Hierarchical at 0x7fcec584bc50>"
      ]
     },
     "execution_count": 56,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "nl_hpc.train(dataset, regimen)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 59,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "56"
      ]
     },
     "execution_count": 59,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "regimen.n_steps"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 70,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "[array([[ 2.8837492e+00, -3.7443317e-02,  7.9923257e-02, -3.8907221e-03,\n",
       "          1.2991955e+00, -9.2964721e-01,  1.7310145e+00, -1.0551074e+00,\n",
       "         -4.6313744e-02,  2.4109759e+00],\n",
       "        [ 3.8792734e+00,  2.2219341e-01, -5.0290971e+00, -6.5246401e+00,\n",
       "          4.7480783e+00, -5.7069695e-01,  3.9169900e+00, -7.0382148e-01,\n",
       "          3.5873923e-01,  6.0888557e+00],\n",
       "        [-1.3446310e+00,  3.9651718e+00,  3.3398464e+00,  4.2438636e+00,\n",
       "         -2.2853000e+00, -1.4398677e+00, -1.1468704e+00, -1.7205951e+00,\n",
       "          7.5127740e+00, -2.5554745e+00],\n",
       "        [ 6.7980361e-01, -1.6588869e+00, -1.8571947e+00, -2.7389359e+00,\n",
       "          3.3541498e-01, -7.7437919e-01,  2.0390060e+00, -1.3918231e+00,\n",
       "         -3.2324989e+00,  8.7470859e-01]], dtype=float32),\n",
       " array([ 1.2566528e-01,  5.2368156e-05, -1.0397015e-03,  8.7433435e-02,\n",
       "        -2.7804275e-03,  1.1844102e-02,  3.8001493e-01,  2.4863838e-01,\n",
       "         1.6591467e-02,  2.7736458e-01], dtype=float32),\n",
       " array([[ 1.78258109e+00,  4.78069574e-01,  1.66839135e+00,\n",
       "          5.76876342e-01,  1.24916339e+00, -1.88567996e-01,\n",
       "          5.21581709e-01, -2.47649288e+00, -5.93566857e-02,\n",
       "          5.39715052e-01],\n",
       "        [ 8.95016956e+00,  4.28393269e+00,  1.31501455e+01,\n",
       "          5.83420658e+00,  9.68733406e+00, -6.08939767e-01,\n",
       "          2.40052199e+00, -1.82959690e+01, -4.74547338e+00,\n",
       "          2.55740356e+00],\n",
       "        [ 3.20228410e+00,  3.71377611e+00,  6.51098394e+00,\n",
       "          4.40320939e-01,  4.01200962e+00, -1.04187024e+00,\n",
       "          9.59550798e-01, -7.99826622e+00, -3.49861765e+00,\n",
       "          3.22039795e+00],\n",
       "        [-2.36524653e+00, -2.75093198e+00, -4.95601130e+00,\n",
       "         -5.16812384e-01, -3.10123277e+00,  7.20997274e-01,\n",
       "         -6.86877012e-01,  6.10484028e+00,  2.70419478e+00,\n",
       "         -2.29128575e+00],\n",
       "        [ 1.58184671e+00,  1.70811284e+00,  2.99464846e+00,\n",
       "          4.31319863e-01,  1.79844177e+00, -5.22476673e-01,\n",
       "          4.53266412e-01, -3.57005763e+00, -1.74213827e+00,\n",
       "          1.76573694e+00],\n",
       "        [ 7.80998886e-01,  1.15122676e-01, -5.89623034e-01,\n",
       "         -1.12004936e+00, -7.34086871e-01, -4.72910643e-01,\n",
       "          3.90687436e-01,  7.95566678e-01,  8.23183060e-01,\n",
       "          1.12950909e+00],\n",
       "        [ 8.74593914e-01,  1.04533064e+00,  1.76636755e+00,\n",
       "         -1.72515139e-02,  1.07180262e+00, -3.20826828e-01,\n",
       "          2.79455155e-01, -2.17912292e+00, -9.17114317e-01,\n",
       "          9.13124859e-01],\n",
       "        [-5.72183669e-01,  1.79622754e-01,  1.19195330e+00,\n",
       "          1.41002786e+00,  1.11665833e+00,  4.39399928e-01,\n",
       "         -3.56333762e-01, -1.49161971e+00, -1.29590034e+00,\n",
       "         -8.91017795e-01],\n",
       "        [-4.81253910e+00, -2.09775949e+00, -6.67121220e+00,\n",
       "         -3.01234174e+00, -4.93073130e+00,  3.18607867e-01,\n",
       "         -1.30927384e+00,  9.36733150e+00,  2.21755004e+00,\n",
       "         -1.31705809e+00],\n",
       "        [-2.93126488e+00, -2.27546358e+00, -4.50314283e+00,\n",
       "         -6.95348799e-01, -2.88045168e+00,  7.22559214e-01,\n",
       "         -8.64897549e-01,  5.74293852e+00,  1.93926048e+00,\n",
       "         -2.26320577e+00]], dtype=float32),\n",
       " array([ 0.4016575 ,  0.16226059,  0.0993211 , -0.31631207, -0.02590228,\n",
       "        -0.17703176,  0.16789462, -0.13561982,  0.16366298,  0.42399663],\n",
       "       dtype=float32)]"
      ]
     },
     "execution_count": 70,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "nl_hpc.predictor.get_weights()"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Several layers"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 24,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "# Tier 2: tier_2\n",
      "## Connecting Predictor\n",
      "Model: \"sequential_2\"\n",
      "_________________________________________________________________\n",
      "Layer (type)                 Output Shape              Param #   \n",
      "=================================================================\n",
      "dense_2 (Dense)              (None, 4)                 12        \n",
      "=================================================================\n",
      "Total params: 12\n",
      "Trainable params: 12\n",
      "Non-trainable params: 0\n",
      "_________________________________________________________________\n",
      "## Connecting State Prediction\n",
      "Loss-driven state prediction.\n",
      "Loss function: <function mean_squared_error at 0x7fa7d389aa70>\n",
      "# Tier 1: latent_layer\n",
      "## Connecting Predictor\n",
      "Model: \"sequential_1\"\n",
      "_________________________________________________________________\n",
      "Layer (type)                 Output Shape              Param #   \n",
      "=================================================================\n",
      "dense_1 (Dense)              (None, 10)                40        \n",
      "=================================================================\n",
      "Total params: 40\n",
      "Trainable params: 40\n",
      "Non-trainable params: 0\n",
      "_________________________________________________________________\n",
      "## Connecting State Prediction\n",
      "Loss-driven state prediction.\n",
      "Loss function: <function mean_squared_error at 0x7fa7d389aa70>\n",
      "# Tier 0: tier_0\n"
     ]
    }
   ],
   "source": [
    "hpc.add_tier(shape=(2, ))\n",
    "hpc.predictor = keras.Sequential([\n",
    "    keras.layers.Dense(4, input_shape=(2, ))\n",
    "])\n",
    "hpc.state_prediction = pc.StatePrediction()\n",
    "hpc.summary()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 25,
   "metadata": {},
   "outputs": [],
   "source": [
    "state_regimen = pc.SimpleOptimizerRegimen(keras.optimizers.Adam())\n",
    "predictor_regimen = pc.SimpleOptimizerRegimen(keras.optimizers.Adam(), eps=1e-7)\n",
    "regimen = pc.ExpectationMaximizationRegimen(\n",
    "    state_regimen=state_regimen,\n",
    "    predictor_regimen=predictor_regimen\n",
    ")"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 26,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "<predicode.hierarchical.hierarchical.Hierarchical at 0x7fa71009c190>"
      ]
     },
     "execution_count": 26,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "hpc.train(dataset, regimen)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 27,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "image/png": "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\n",
      "text/plain": [
       "<Figure size 640x480 with 1 Axes>"
      ]
     },
     "metadata": {
      "needs_background": "light"
     },
     "output_type": "display_data"
    },
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "<ggplot: (8772246476353)>\n"
     ]
    },
    {
     "data": {
      "image/png": "iVBORw0KGgoAAAANSUhEUgAAAm8AAAGMCAYAAACMDkU5AAAABHNCSVQICAgIfAhkiAAAAAlwSFlzAAAPYQAAD2EBqD+naQAAADl0RVh0U29mdHdhcmUAbWF0cGxvdGxpYiB2ZXJzaW9uIDMuMC4yLCBodHRwOi8vbWF0cGxvdGxpYi5vcmcvOIA7rQAAIABJREFUeJzt3XuY3NV93/HP2V2thNANSRYCSRgLibu5WuEiqLgmpiZVXSBpS1zs4Dy249LWcdyEgu0Em/ipaZv2sR87j52mpiF2Y2OMsSGAAXMRPAYLIQgIRwghhMRNSF6hC0Ka3dM/Zlfay8zsznx/M99zdt6v51kvOzM7v4+8j6SPzjm/c0KMUQAAAMhDh3cAAAAAjB3lDQAAICOUNwAAgIxQ3gAAADJCeQMAAMgI5Q0AACAjlDcAAICMUN4AAAAyQnkDAADICOUNAAAgI5Q3AACAjFDeAAAAMkJ5AwAAyAjlDQAAICOUNwAAgIxQ3gAAADJCeQMAAMgI5Q0AACAjlDcAAICMUN4AAAAyQnkDAADICOUNAAAgI5Q3AACAjFDeAAAAMkJ5AwAAyAjlDQAAICOUNwAAgIxQ3gAAADJCeQMAAMhIl3eA4fbtU/TOAJsJG17wjgCjH6xe7B0BBlcc/qh3BFgtXRq8IyBdjLwBAABkhPIGAACQkeSmTSfs/LV3BFi9+qp3Ahjt3cu0adZ6erwTAGgiRt4AAAAyQnkDAADISIgxsZs7t2xJLBDqVip5J4BR75zDvCPAoHP3Du8IsJo6lbtNURUjbwAAABmhvAEAAGSE8gYAAJCR5LYK0aZN3glgtX69dwIYPXH4Zd4RYHDW3lXeEWC1bJl3AiSMkTcAAICMUN4AAAAyktxWIa+9xsH0uVu3zjsBrM7te8g7Agx+OZkpt9wtWSK2CkFVjLwBAABkhPIGAACQEcobAABARpLbKuSwydu9I8BoztnTvSPA6olu7wQwmD3bOwGAZmLkDQAAICOUNwAAgIwkN226ZS9TbrlbdZ93Alj91soHvCPA4IG5Z3lHgNHVV3snQMoYeQMAAMgI5Q0AACAjyU2b9vV5J4DVzJneCWB23nneCWBwEjcLA+MaI28AAAAZobwBAABkhPIGAACQkRBj9M4wxJYtSisQ6lYqeSeAVTdrprI2a0avdwRYdXYG7whIFyNvAAAAGaG8AQAAZCS5rUImTfJOAKupXe94R4DRIysP8o4Ag3PnrveOAKvFi70TIGGMvAEAAGSE8gYAAJCR5KZNe3q8E8Bq1Xqm3HK3TA95R4DBo28u844Ao6XMmqIGRt4AAAAyQnkDAADICOUNAAAgI8mteZs92zsBrNat804As/vu9U4Ag18tZM1b7pYu9U6AlDHyBgAAkBHKGwAAQEaSmzZdvdo7AazuuMM7AazO3/2WdwQYrNnjnQBAMzHyBgAAkBHKGwAAQEZCjNE7wxDbtyutQKjb9Gn8CHP31OrgHQEGp87Z7B0BVvPm8ZsQVTHyBgAAkBHKGwAAQEYobwAAABlJbquQ6T0ve0eA1X0rvRPA6PZnLvOOAINTZ9/mHQFW11zjnQAJY+QNAAAgI5Q3AACAjCQ3baqdO70TwGr3bu8EMFq0yDsBTCYf7p0AQBMx8gYAAJARyhsAAEBGkjthQVu2JBYIdevp8U4Ao82TF3tHgMG8vle8I8BqwQJOWEBVjLwBAABkhPIGAACQEcobAABARpLbKiTOfo93BBit3MDPMHdL7vpf3hFg8MP5/9E7AowuW+CdAClj5A0AACAjlDcAAICMJDdtumaNdwJYbdrknQBWS8480zsCDOaWvBMAaCZG3gAAADJCeQMAAMgI5Q0AACAjya15O2Htj7wjwOiEu+7yjgCjG4/8tncEGFy394veEWC19M+9EyBhjLwBAABkhPIGAACQkeSmTcUWBfmbOdM7AYyO3+adACZTzvFOAKCJGHkDAADICOUNAAAgI+lNm27Y4J0AVrfe6p0ARrduW+YdAQYfnnabdwRYXXyxdwIkjJE3AACAjFDeAAAAMkJ5AwAAyEiIMXpnGGLzZqUVCHVbu9Y7AazO332ndwQY3D/pQ94RYHThhQreGZAuRt4AAAAyQnkDAADISHLTpu+8w7Rp7vbs8U4Aq0P6tnpHgMFWzfKOAKNZs/KeNg0h/JmkL0p6JMb4zyo898cxxikO0cYFRt4AAECznBtCuMA7xHhDeQMAAM2wS9LjKo/AoUDJnbCwapV3Alg9+KB3Alhd1/Et7wgw+E73td4RYPTZz3onKMwNku4MIZwXY3yw0gtCCDMlfVXScklTJP2jpOtjjPcOes2DknZKulnSlyXNk/SEpD+IMb446HUTVS6LV0qaK2m9pC/FGL9b+K/MESNvAACgKWKMd0n6paQ/q/R8CKFT0j9I+rCk6yRdJukNSXeFEM4f9vJTJP2xpD+V9FFJR0u6Zdhrvi/pE5L+u6RLJd0t6ZYQwiX2X006kht5AwAA48oNkn4SQlgWY3xo2HMfkvQbkj7UX/QUQrhb0rMqj6D9fNBrZ0g6Nca4pf91MyR9O4QwP8a4qb/s/QtJvzVo1O5nIYR5kv5c5ZI4LjDyBgAAmibG+FNJq1R57du5knYMFLf+1/epPIJ2dv/I3IDVA8Wt35r+z/P7P/+mpG2SHgghdA18SLpf0qnD3itryY28HX+8dwJYLT1xu3cEGN18O2umcvbZhY94R4DZud4BinaDpNtDCMN/YYeoPE063OuSJqi8Bm7gL5WeYa/Z2/95Uv/n2ZJmStpXJcNhkjbVkTlZyZU3AAAwvsQYfxxCWK3y6NuKQU9tk3RohW+Zq3IJ21nHZbZJ2iLpn1d5/s063itplDcAANAKN0i6bdhjKyR9LoTwwRjj3ZIUQuiQdIWkx2KMvXW8/32S/rOkvTHGZ4oInKrkytu0ad4JYLVrz3TvCDC66oJXvCPAYHPHuJtyazvzvAM0x+2SnpF0ocp7wEnSnSpv+fG3IYT/ovK05iclHSPp0/W8eYzxZyGEn0i6O4Tw1f5rHSzpBEmLYowfL+RXkYDkyhsAABh/YowxhHCDpFsHPdbbv43HTZK+ovIat2dUvvv0wQYuc7nKW4n8oaT3qrxe7llJ/8eWPi3JnW3a28vZprnjbNP8HbyNkbecbe5Y4B0BRvPm5X22KZoruZG3TtUzvY0UrV49bu7GbltL7/or7wgweODYG70jwOgjH/FOgJSxzxsAAEBGKG8AAAAZobwBAABkJLkbFnbs4IaF3E2dwo8wd08/w1rpnJ08kxtOsrdgAb8JURUjbwAAABmhvAEAAGQkua1Cnn3WOwGsvvtdRvtz97Ue9inI2aem/K13BBh985veCZCy5MobAADI1OzZn5Z0scqHxPdI2tHkK3ZImi7pkP6PP9Vbb437YSDKGwAAKEZHxwcUwvL9X7fypsgQJOnrKh+HNa5R3gAAQDG6umofk9SMMheGLNVpi+0OkitvZ01+2jsCjM5a9KB3BBj9ZR9rpnL2zUksmMrfp7wDNKazzuMRB8rcWErdQEkLrKtOrrwBAIBMdRg2sahW4ChrI1DeAABAMeodeRsuRsraGKRX3hYt8k4Ao+1HnuwdAUafWf2QdwQYPD8n0yk37Hecd4BG1TPyNrikVSps9Uyptpn0yhsAAMjTWEfeGhldo8TtR3kDAADF6Ow8p+LjzZgKrVzm3i/pnuIvlpbkytv9vzjYOwKMnnnGOwGsPnNSyTsCDNau9U4Aq+NynTft7Py1pNavWxsociH0tPbCPpIrbwAAIFPd3c9JOnPE482e8jxQFl9p7oXSQHkDAADFGOuat0ZvRhjtJoc2QXkDAADFaHSft3o26UV65W3bNu8EsPrFL7wTwGz97d4JYPBAx4XeEWC0fPnor0mSZZNeiX3exii58gYAADLVyCa9w4+9GjwKx/YgFVHeAABAMeopb2MdYaPAjZBcebvgAu8EsDr2WO8EMOv7uHcCGHyy2zsB2lZn55yazxcxJVq7zE21XyB9yZU3AACQqc7O04aUq1asXxt6vZMk3dr8i/qivAEAgGJ0d98t6eohj7Vy2jOER1t3MT/JlTd2589fX593AlhtPeVk7wgwmGu84Q9o2Ghr3oq6GWH4TQ5tJrnyBgAAMlXvViGWTXrbGOUNAAAUo5GtQgYbmLrhJIWaKG8AAKAYlk16Qyh/fwhsDzKK5MpbT493Alg98IB3Alhd+MRXvCPA4Eula70jwOjzn/dO0CDLJr2VUOIqSq68AQCATNUaeSviJoNGD7QfZyhvAACgGJ2dHxzxWLPWrFUucGdJuqc5F0xHcuXtoou8E8DqgyN/6yIz2/cy7Zazz0/e5x0BZhO8AzSmq2u1Qpjnsm6tfL3nWntRH8mVNwAAkKnu7terPteMKc+RU7FvF/fm6aK8AQCAYtRzt2kRm/S2qeTKWzcHKmevVPJOAKvpHTu8I8DgnVJbnM09rh2U6aypaZ+3GEcWuoJOUgghzJD0LUmXqDw6d2OM8RsVXnekpJck7Rr08C0xxk+aAhQsufIGAAAyZdnnbUCMzRhZ+7rKnedwSYsk3RdCeD7G+PMqr58dY9xTdIiiUN4AAEAxLCNvgwtbgeviQggHS7pC0qkxxh2SngohfEfS70uqVt6SRnkDAADFGMvIWyNTobabHY6WFGKMawY9tlrSH9X4nnUhhA5JD0v6XIzxlUYu3CzJlTfWS+Vv927vBLA6eA9HneTs7W7WvOXuoIO8EzTmxXPOubRnwYKqz5/+gx8Ucp0nr7ii4uNz1q5dvmDkPm9TNPIu1B5JlX6jvCVpicrlbrqkr0r6SQjh9Bhjryl0gZIrbwAAIE8dUu3aaT24frTr9/VVKmQ7JU0b9th0SSPuzIox7pS0sv/LrSGEP+x/3WJJvyowqgnlDQAAFKI0ceJrGlmUDuhqbu3YO2XKyxUeXisphhCOizE+3//YKZKeHcNbxv6PpPYmSa68HbwtqWllNODgxx7zjgCjm/f8rncEGFw15YfeEWB12WXeCRqyeOXKFZKOqfqCrq5CbkY4/c47q62Ze0TLlw95IMa4K4Rwq6QvhRA+JmmhpI9K+p3h3xxCOEPlKdZ/UrmEflXSOpULYDKSK28AACBTjUyLjnYzwuCS1vgWIp+W9G1Jr6lczr4QY3wghHCEpDWSjo8xblS52N0o6VCVp0tXSLo0pfVuEuUNAAAUxbrPW7VNeo1ijD0qbxcy/PGNKt/QMPD19yR9r5CLNlF65Y0jFvJ30UXeCWB0Vdd27wiwmPavvBOgXVlvSPA40D5D6ZU3AACQp7GOvI11r7fBRY5Stx/lDQAAFKOzs3Z7s06DUuAkUd4AAEBROjsvHfFY8eeUHjByjdyFGrlJ77iTXHm7/9lDvSPAaOXK0V+DtP3JIraayNnf7clzmwkccOWV3gka1NV1t0L4yP6vWzlSVi6JWZ5VWq/kyhsAAMjUhAl7az7fjDI3dGSvr/gLpIfyBgAAilHP3ab13ozQyIH241Ry5e3ss70TwGrGDO8EMFtX8k4AgzlzvBOgbVn2eRvLJr2QlGB5AwAAmbLu8zZQ4ChsNVHeAABAMeodeas1FTrasVltjPIGAACKMdaRt0ZG1ihx+yVX3g7qTursVzTgxBONw+bwN4fFpzn7wJTRXwM0RWfnWRUfL3oatHqRO0Hs8wYAADBGnZ27JLV+zdqBMreztRf2QXkDAADF6O5+RtKSEY+3YsqzXBhfbv6F/KVX3h5+2DsBjCauW+cdAUa/POUPvCPAYEnPz7wjwOrii70TNGasa94sNyOw31uC5Q0AAOSp0X3e6tmkF5Q3AABQEMsmvVK5xFHSRpVceXvxiPO9I8Do8DP5GeZuz0rvBDA59ljvBGhXjWzSO3watN5js9pQcuUNAABkqt7yNpZRNgrcCJQ3AABQjI6OmRUfL/Img9o3O0y2XyB9lDcAAFCMrq4zh5SqVqxfG3q90yX9qPkX9ZVceVu40DsBrMKrm70jwKhUmucdARZvv+2dAO2qu/suSVcPeayV054hPNK6i/lJrrwBAIBMjbbmraibEdp8rzfKGwAAKEa9W4VYNultY8mVt/DWFu8IsJrcFutFx7Xzj33NOwIM3plxgncEGB3kHaBRjWwVMlhfX/nz4IJGWRshufIGAAAyZdmkN4TyR0cH24OMgvIGAACKYdmkt9L3U+IqSq+83XGHdwJYXX+9dwIYhdeZNs1ZnHuYdwRYvZbp78FaI2/Wmww4eWG/9MobAADIU2fnb1Z8vBnr1ioXuLMk3VP8xdJCeQMAAMXo6npOISxQCK0fHStfb01rL+qD8gYAAIoxYUL1XdqbUeZGjuhtL/4i6UmuvD112tWjvwhJe/Wv+RnmLi583jsCDJ7cnel6Kex3uneARtVzw0IRm/S2qeTKGwAAyFSj+7xVO2y+zU9SqIbyBgAAimHZ521AjJS1USRX3o491jsBrLZt804As9tu804Ag2fnX+cdAUan5zpvajlhYXBhK3h9XAhhhqRvSbpE0tuSbowxfqPQi7RQcuUNAABkaiwjb41MhVabVh27r6vceQ6XtEjSfSGE52OMP2/0DT1R3gAAQCFiZ+fRVStZkVOhVUpclA4bfpUQwsGSrpB0aoxxh6SnQgjfkfT7krIsbyEmtkvxrl1KKxDqNmmSdwJYvf66dwJYzJvSFrsljG/Tp2e56Gv9iy9u/3VPz7Rqz5928imFXGfV06srPn7onDnfnb9gwZWDHwshnCrp8Rhj96DHPiLpj2KMpxYSqMUYeQMAAIXYV+p9TVLV8lYqlTtps+5HePfdfS9VeHiKyuvcBuuRNLU5KZqP8gYAAIoxytxZb9+gLwYVuLGUuf0ThTWuUWUycadGFsrpknaMftU0Ud4AAEAhFsxftELSMdWe7+ur9oz2l7mBIjekiA0rZccdU3W285EKj62VFEMIx8UYB3YgP0XSszXSJC258nbwr570jgCru+/2TgCj/9vBVhM5u3bS33hHgNVnPuOdoCF90TAf2qQV7zHGXSGEWyV9KYTwMUkLJX1U0u8054rNl1x5AwAAeao5slZBrR1ACj5c4dOSvi3pNZXXv30hxvhAIe/sgPIGAAAK0TtKeRtZ0mo0s7j/f4Z+RwNlLsbYo/J2IeNCeuVt4ULvBDB66d8y5Za7a7//X70jwODHC//EOwKMlnsHaFBvr0L1gxIaGUKr9j0H3riJBzMkK73yBgAAstTbG367NceSVr5I7NMFku5pRQJPlDcAAFCIfft0r6Qrqz1fdLGrMNL2ULFXSBPlDQAAFKKvT3vqeX1j69dqPt1b/zvmJ73yVu+tKkjO+1Rpg2vkZPPvsWYqZ8u12TsCzOZ5B2hIr7E6VSpz7bKOrR7plTcAAJClIssbpa06yhsAAChEI5Nng0tajIXv7zYupVfeVqzwTgCr227zTgCj/zbzZu8IMPjLrv/pHQFWN93knaAhYxl5a3REjTJ3QHrlDQAAZKnayFutkxTqxcgc5Q0AABSkVNIZIfisVwtB6uvTcWKft9b72sZc95XGgAd38jPM3Q//5Y+8I8Dga5vynHLDAdd4B2jQ3r3aW21ErJkjZQNr5fr69G7zrpKO5MobAADIU1+fnpJ02mivsxa5GiN7623vnAfKGwAAKESjW4WMVubYNmQoyhsAAChEEfu8DRS5Im9yGG+SK2/XnPKIdwQYXXP8Xu8IsDr+TO8EMLhmZlss+xnnJnoHaIjlkKSBdWuD93pDZcmVNwAAkKd6Rt7qGVGjzA1FeQMAAIWoNfJmnQZlf7cDkitv+8481zsCjHbv9k4Aq+mlrd4RYLB1Z55TbjhgVqY/wlJJ04evWWu2YeehZvr/XH2SK28AACBPpZLOdd6k90xJd7T+6q1FeQMAAIUolfRTSVfXek2R054VSuJDxb17upIrbxPeZromd9N7erwjwGjrjKO8I8BgVukN7wgwO9Q7QEMa2SqknjLHtiFlyZU3AACQJ+smvcOLHHu9VUZ5AwAAhbDs84axo7wBAIBCNFLeKo2usS1IbcmVtzhzlncEGIW33vKOAKPbb/dOAIurD1/lHQFWl1zinaAhY5k2bWQqlDI3VHLlDQAA5KlSeWvmerV2LXOUNwAAUIhSSRd5Xj9G/YakezwztEJy5S2sf9E7AqzWrfNOAKMjjzzGOwIsuqd4J0Cb2rdPa0PQe72uH6Pa4i+g5MobAADIU2+vNo71tZYpzxpTsdsaf9d8UN4AAEAhLJv01ipz7Pc2VHLl7aFN7Oyeu7+6hZ9h7r736jLvCDD43bltcULQuPb353onaEwR+7x5nY2ak+TKGwAAyFOj5a1SWWvXO0nHgvIGAAAKMdZp08FlrdYoG/u7VUZ5AwAAhahV3oqcCm1WmQshfFnSJ1XuR9+T9B9ijPuqvHaDpEMlDfyqX44xntCcZEMlV96WzWerkNwt+3drvSPA6KHJrJnK2d+Ln1/+8lx32turowaKVStuMhg+Mhej5jT+XuHjkv61pA9I2iXpp5Kul/TFGt/24Rjj3Y1es1HJlTcAAJCnUklHeF4/Rs03fPvHJP2PGOMGaf8o3DdUu7y5oLwBAIBC7Nunn0taONrripj2rDKiZznY90RJTw/6erWk+SGE6THG7VW+5+YQQoek5yRdF2N81HD9MUuvvBVxnzF8rVjhnQBG/+muPA/FRtlTi77uHQFWy/KcNj377BfOmTv37arP33rr6SMeG2uRG1zWLr/8yYqvefnlmedK7xtxPFYIoVNStSvFGGOvpCmSBpe0nv7PU4c9PuD3JA0E+aikfwghvD/G+HLVX0RBOpp9AQAA0B5GW9/W2zvyo1Qa+jHa4w3eFHG/pH1VPjb3v2anpGmDvmd6/+cdla8VV8QY3+n/+KakpyS15F++6Y28AQCAcclrci3GeN4YXvaspJMlPdb/9SmSNtWYMh2uT9VH9wpFeUPxTjrJOwGM/v2oK1aQtK5LvROgTd1//+IVko4Z6+tr3ZFaa4+3W24ZOf3a75HLLhvr1Uf4jqTPhRDuUvlu0+sl/U2lF4YQjpD0XkmP9z90laQlkj7e8NXrQHkDAACFGG2T3iK2DWnihr1/rXIhe1LSBJX3efvygeuG5yT9RYzx71ReH/c1SYsk7ZW0RtKlMcaW7HdGeQMAAIXo7R1arpq111szTl6IMUaVR9uur/L8CYP+e43K06ouKG8AAKAQpZJ+2/Moqxh1nqQRd5uON+mVt0mTvBPAavdu7wQw2rDBOwFM5u70ToA2tW+f7pf0b6o934xiN2xUryX7rHlLr7wBAIAs9fWprn+9N1LmRpmCrXgO6XhDeQMAAIUY7YaFSgYXuEplrhVnpOYmvfK2caN3Ali9XX13beRhvuV0QPjrY/91+GikvA1W6WYHjJReeQMAAFlqZBPewSUtxubcSTreUN4AAEAhxjry1sioGmXuAMobAAAoRLWRtyLXrTEyl2B5e+e0pd4RYLR+Bj/D3H1i3Y+9I8Dg0dmf8o4Ao1z/FC2V9IEQfNarhSD19Wmx2OcNAABgbPbt05Da1urRMa+D71uN8gYAAArR26snNYZjo6ylrsbI3gu2d85DcuXtoL5d3hFgdPTRB3tHgNki7wAwOGKadwK0q3q3Cqln/Rr7vR2QXHkDAAB5KmKft4EiR1mrjvIGAAAKYVlzNniPN9SWXnnbs8c7AYwmvPmmdwQYbZ5xgncEGCzY+5J3BJi9zztAQ+opb6ONrI12bFY7S6+8AQCALNWaNi1q+pMiR3kDAAAFKZU0pdXnkw673oTmX9Ef5Q0AABSiVNL5niNjMWqppJ/6JWiN5MrbL9fP8o4Ao40b+Rnm7rKFT3lHgMGju0/1jgCjpXkueVOppJ9IurrWa4osdxVG9h4s7t3TlVx5AwAAeRrrViGN3ozA9iFllDcAAFCIRvd5q7ZZ7+CS1u6FbbDkytuSk971jgCjRYsmekeA1dq93glgcPjh3gnQroo4W3T4Jr0YKbnyBgAA8tRIeas0FVrPsVntiPIGAAAKMZZpU8uIGmWuLLny9vSvmHLL3fr13glg9eH5Hd4RYLBpk3cCWL0v07tNK5W3Zk5/tmuZS668AQCAPPX26kKva4cg9fXpdEn3eGVoFcobAAAoxN69Wh+CjvS6fox6xevarUR5AwAAhejr00tjfa1lyrPGVOybjb9rPpIrbycfy1YhuTt59lveEWD0XM8S7wgwOHfmi94RYHaUd4CGNLLP21juLGVz3qGSK28AACBPRe3zRkmrjfIGAAAK0Wh5q1TW2vVO0rFIr7ytXu2dAFb8DLO3esonvCPA4AT9wjsCrI4a39Om9Y6sUeSGSq+8AQCALNUaeStyKrTdyxzlDQAAFKK3VzMG/ruV69YGnYd6UOuu6ifExFYF3nST0gqEun3hC94JYPXO5FneEWCwYPJW7wgweuUVZTm2FIIWSponaYekPa26rKTJkqZKWhWj3m7Rdd0w8gYAAAoRo9ZL4pDEJuMAQwAAgIxQ3gAAADKS3Jq3LVtY85a7tzhgIXvHlf7ROwIMXpj0fu8IMFq8OM81b2gNRt4AAAAyQnkDAADISHLTpnrxxcQCoW5FHG4HX/PneyeARanknQBWU6cybYqqGHkDAADICOUNAAAgI5Q3AACAjKR3wsLMmd4JYPXqq94JYPTQE21xPOC4tWzS494RYHXGGd4JkDBG3gAAADJCeQMAAMhIeluFvPtuYoFQtw7+TZC93bu9E8Dg3UnTvSPAaOJETlhAdfwtCwAAkBHKGwAAQEaSu9v0nzZM9I4AI2bc8nfqKdO8I8Bgd493AlhN5K9C1MDIGwAAQEYobwAAABmhvAEAAGQkuTVvHLCQv507vRPAbNUq7wQw2Nh1uncEGB1yiHcCpIyRNwAAgIxQ3gAAADKS3LTpezY+6R0BRu+5917vCDC69u1rvSPA4CtTbvSOAKuTr/NOgIQx8gYAAJARyhsAAEBG0juYfuvWxAKhXnHmLO8IMAoPP+QdAQYvHL7MOwKMFi/mYHpUx8gbAABARihvAAAAGaG8AQAAZCS5NW8xKq1AqFvY+653BBi90TPROwIMDu3+tXcEWB1yCGveUBUjbwAAABmhvAEAAGQkuRMWwltbvCPAas0a7wQqL8uzAAADL0lEQVQwum8TW03k7MopD3tHgNXy5d4JkDBG3gAAADJCeQMAAMhIcnebvvEGd5vmriu5yXjUq4N/1mXtkBn8MZq9ELjbFFXxRzQAAEBGKG8AAAAZobwBAABkJLnVSa+/7p0AVitXeieA1dX6394RYHBz19XeEWB01VXeCZAyRt4AAAAyQnkDAADISHJbhei55xILhLr19HgngFE8e6l3BBiEbVu9I8Bq1iy2CkFVjLwBAABkhPIGAACQkeTuNmVr93Fg0iTvBDAKfb3eEWDBn6PAuMbvcAAAgIxQ3gAAADJCeQMAAMhIemveNmzwTgCrV1/1TgCjN+af7h0BBoduXOcdAVZLlngnQMIYeQMAAMgI5Q0AACAjyU2b7rvoEu8IMJrQs8U7AoyefcY7ASwOnd3tHQFAEzHyBgAAkBHKGwAAQEYobwAAABkJMUbvDEO88ILSCoS67d7tnQBWJx/9jncEGGzedpB3BBjNm6fgnQHpYuQNAAAgI5Q3AACAjCS3Vcjijhe9I8Do3WOP8o4Aq//3fe8EMNh49FXeEWA0b553AqSMkTcAAICMUN4AAAAykty06eZJTLnl7rE7vBPA6opt27wjwGD9eu8EsDrrLO8ESBkjbwAAABmhvAEAAGSE8gYAAJCR5Na8bdzonQBWHfyTIH+XX+6dAAYnsmQRGNf4axYAACAjlDcAAICMJHcwvXbtSiwQ6jZpkncCWLFVSNZ2THqPdwQYTZ3KwfSojpE3AACAjFDeAAAAMpLc3abcbjoObNrknQBGj0+72DsCDM4oPeodAVZLl3onQMIYeQMAAMgI5Q0AACAjlDcAAICMpLdVCAAAAKpi5A0AACAjlDcAAICMUN4AAAAyQnkDAADICOUNAAAgI5Q3AACAjFDeAAAAMkJ5AwAAyAjlDQAAICOUNwAAgIxQ3gAAADJCeQMAAMgI5Q0AACAjlDcAAICMUN4AAAAyQnkDAADICOUNAAAgI5Q3AACAjFDeAAAAMkJ5AwAAyAjlDQAAICOUNwAAgIxQ3gAAADJCeQMAAMgI5Q0AACAjlDcAAICMUN4AAAAyQnkDAADICOUNAAAgI/8fm1Vu/HM9aqIAAAAASUVORK5CYII=\n",
      "text/plain": [
       "<Figure size 640x480 with 1 Axes>"
      ]
     },
     "metadata": {
      "needs_background": "light"
     },
     "output_type": "display_data"
    },
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "<ggplot: (8772246307033)>\n"
     ]
    }
   ],
   "source": [
    "print(lazytools.matrix_heatmap(hpc.tier(2).numpy(), pole=0))\n",
    "print(lazytools.matrix_heatmap(hpc.tier(1).numpy(), pole=0))"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 28,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "image/png": "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\n",
      "text/plain": [
       "<Figure size 640x480 with 1 Axes>"
      ]
     },
     "metadata": {
      "needs_background": "light"
     },
     "output_type": "display_data"
    },
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "<ggplot: (8772246383321)>\n"
     ]
    }
   ],
   "source": [
    "print(lazytools.matrix_heatmap(hpc.predictor.get_weights()[0], pole=0))"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 29,
   "metadata": {},
   "outputs": [
    {
     "name": "stderr",
     "output_type": "stream",
     "text": [
      "WARNING: Logging before flag parsing goes to stderr.\n",
      "W0905 15:51:56.482789 140359989610304 backprop.py:1002] The dtype of the source tensor must be floating (e.g. tf.float32) when calling GradientTape.gradient, got tf.int64\n",
      "W0905 15:51:56.656086 140359989610304 backprop.py:1002] The dtype of the source tensor must be floating (e.g. tf.float32) when calling GradientTape.gradient, got tf.int64\n",
      "W0905 15:52:00.137444 140359989610304 backprop.py:1002] The dtype of the source tensor must be floating (e.g. tf.float32) when calling GradientTape.gradient, got tf.int64\n"
     ]
    },
    {
     "data": {
      "text/plain": [
       "<predicode.hierarchical.hierarchical.Hierarchical at 0x7fa71009c190>"
      ]
     },
     "execution_count": 29,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "state_regimen = pc.SimpleOptimizerRegimen(keras.optimizers.Adam())\n",
    "predictor_regimen = pc.SimpleOptimizerRegimen(keras.optimizers.Adam(), eps=1e-7)\n",
    "regimen = pc.ExpectationMaximizationRegimen(\n",
    "    state_regimen=state_regimen,\n",
    "    predictor_regimen=predictor_regimen\n",
    ")\n",
    "hpc.train({'tier_2': np.array([[1, 0]])}, regimen)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 34,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "<tf.Variable 'hierarchical_2_tier_0_copy:0' shape=(1, 10) dtype=float32, numpy=\n",
      "array([[ 1.4771166 , -1.5336497 , -1.7164751 , -0.324072  , -1.9606574 ,\n",
      "         1.0581334 ,  1.2764759 ,  1.4185038 , -0.18543616, -0.54926646]],\n",
      "      dtype=float32)>\n"
     ]
    }
   ],
   "source": [
    "print(hpc.tier(0))"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Adding in metrics"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Essentially, there are three levels of detail with which to keep track of metrics: per EM step, for every predictor estimation step, for every state estimation step, and for all steps. By having the regimen keep track of which is which, we shouldn't have to worry about which is which within the regimen. We will first, however, just add in EM step metrics that work somewhat more easily."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 1,
   "metadata": {},
   "outputs": [],
   "source": [
    "%load_ext tensorboard"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 2,
   "metadata": {},
   "outputs": [],
   "source": [
    "import predicode as pc\n",
    "import tensorflow as tf\n",
    "import tensorflow.keras as keras\n",
    "hpc = pc.Hierarchical()\n",
    "hpc.add_tier(shape=(10, ))\n",
    "hpc.add_tier(shape=(4, ),\n",
    "             name='latent_layer')\n",
    "hpc.predictor = keras.Sequential()\n",
    "hpc.predictor.add(\n",
    "    keras.layers.Dense(10, input_shape=(4, ), use_bias=False, dtype=tf.float32)\n",
    ")\n",
    "hpc.state_prediction = pc.StatePrediction()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 3,
   "metadata": {},
   "outputs": [],
   "source": [
    "metric = keras.metrics.MeanAbsoluteError()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 4,
   "metadata": {},
   "outputs": [],
   "source": [
    "state_regimen = pc.SimpleOptimizerRegimen(keras.optimizers.Adam())\n",
    "predictor_regimen = pc.SimpleOptimizerRegimen(keras.optimizers.Adam(), eps=1e-7)\n",
    "regimen = pc.ExpectationMaximizationRegimen(\n",
    "    state_regimen=state_regimen,\n",
    "    predictor_regimen=predictor_regimen\n",
    ")"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 5,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "datetime.datetime(2019, 9, 7, 13, 31, 49, 473092)"
      ]
     },
     "execution_count": 5,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "import datetime\n",
    "datetime.datetime.now()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 6,
   "metadata": {},
   "outputs": [],
   "source": [
    "logdir = 'log/{}'.format(datetime.datetime.now())"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 7,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "'log/2019-09-07 13:31:49.495801'"
      ]
     },
     "execution_count": 7,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "logdir"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 8,
   "metadata": {},
   "outputs": [],
   "source": [
    "summary_writer = tf.summary.create_file_writer(logdir)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 9,
   "metadata": {},
   "outputs": [],
   "source": [
    "dataset = pc.decaying_multi_normal(dimensions = 10, size = 100).astype('float32')"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 10,
   "metadata": {},
   "outputs": [],
   "source": [
    "with summary_writer.as_default():\n",
    "    hpc.train(dataset, regimen, metrics = [metric])"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 12,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "Reusing TensorBoard on port 6007 (pid 12272), started 0:00:13 ago. (Use '!kill 12272' to kill it.)"
      ]
     },
     "metadata": {},
     "output_type": "display_data"
    },
    {
     "data": {
      "text/html": [
       "\n",
       "      <iframe id=\"tensorboard-frame-44c7cf0fc3fbd017\" width=\"100%\" height=\"800\" frameborder=\"0\">\n",
       "      </iframe>\n",
       "      <script>\n",
       "        (function() {\n",
       "          const frame = document.getElementById(\"tensorboard-frame-44c7cf0fc3fbd017\");\n",
       "          const url = new URL(\"/\", window.location);\n",
       "          url.port = 6007;\n",
       "          frame.src = url;\n",
       "        })();\n",
       "      </script>\n",
       "  "
      ],
      "text/plain": [
       "<IPython.core.display.HTML object>"
      ]
     },
     "metadata": {},
     "output_type": "display_data"
    }
   ],
   "source": [
    "%tensorboard --logdir log"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "It works!"
   ]
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.7.4"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 4
}
